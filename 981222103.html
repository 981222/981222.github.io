

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/about/avatar.png">
  <link rel="icon" type="image/png" href="/img/about/avatar.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Java多线程 - 松林</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>松林</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-books"></i>
                档案
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-bookmark-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/posts/banner_img/004.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="不要嘲笑那些比你们拼命努力的人，也不要理会那些嘲笑你拼命努力的人。">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-29 15:08" pubdate>
        2020年12月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">不要嘲笑那些比你们拼命努力的人，也不要理会那些嘲笑你拼命努力的人。</h1>
            
            <div class="markdown-body">
              <h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1.并行和并发有什么区别？"></a>1.并行和并发有什么区别？</h2><ul>
<li><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</p>
</li>
<li><p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
</li>
<li><p>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</p>
</li>
</ul>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2.线程和进程的区别？"></a>2.线程和进程的区别？</h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h2 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3.守护线程是什么？"></a>3.守护线程是什么？</h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4.创建线程有哪几种方式？"></a>4.创建线程有哪几种方式？</h2><h3 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h3><ul>
<li><p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p>
</li>
<li><p>创建Thread子类的实例，即创建了线程对象。</p>
</li>
<li><p>调用线程对象的start()方法来启动该线程。</p>
</li>
</ul>
<h3 id="2-通过Runnable接口创建线程类"><a href="#2-通过Runnable接口创建线程类" class="headerlink" title="2.通过Runnable接口创建线程类"></a>2.通过Runnable接口创建线程类</h3><ul>
<li><p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
</li>
<li><p>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
</li>
<li><p>调用线程对象的start()方法来启动该线程。</p>
</li>
</ul>
<h3 id="3-通过Callable和Future创建线程"><a href="#3-通过Callable和Future创建线程" class="headerlink" title="3.通过Callable和Future创建线程"></a>3.通过Callable和Future创建线程</h3><ul>
<li><p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
</li>
<li><p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
</li>
<li><p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
</li>
<li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。需要注意的是在获取返回值时，获取返回值的线程会进入阻塞状态等待子线程结束后的返回值。</p>
</li>
</ul>
<h2 id="5-runnable-和-callable-有什么区别？"><a href="#5-runnable-和-callable-有什么区别？" class="headerlink" title="5.runnable 和 callable 有什么区别？"></a>5.runnable 和 callable 有什么区别？</h2><ul>
<li><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
</li>
<li><p>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
</li>
</ul>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6.线程有哪些状态？"></a>6.线程有哪些状态？</h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li><p>创建状态。在生成线程对象，并没有调用该对象的start方法，这时线程处于创建状态。</p>
</li>
<li><p>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，等待线程调度程序调度运行。</p>
</li>
<li><p>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</p>
</li>
<li><p>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</p>
</li>
<li><p>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　</p>
</li>
</ul>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7.sleep() 和 wait() 有什么区别？"></a>7.sleep() 和 wait() 有什么区别？</h2><ul>
<li><p>sleep()：sleep()方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
</li>
<li><p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
</li>
</ul>
<h2 id="8-锁池和等待池？"><a href="#8-锁池和等待池？" class="headerlink" title="8.锁池和等待池？"></a>8.锁池和等待池？</h2><ul>
<li><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
</li>
<li><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</p>
</li>
</ul>
<h2 id="9-notify-和-notifyAll-有什么区别？"><a href="#9-notify-和-notifyAll-有什么区别？" class="headerlink" title="9.notify()和 notifyAll()有什么区别？"></a>9.notify()和 notifyAll()有什么区别？</h2><ul>
<li><p>如果线程调用了对象的wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，等待池中的线程<strong>不会去竞争该对象的锁</strong>。</p>
</li>
<li><p>当有线程调用了对象的 <strong>notifyAll()</strong> 方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</p>
</li>
<li><p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它<strong>还会留在锁池中</strong>，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
</li>
</ul>
<h2 id="10-线程的-run-和-start-有什么区别？"><a href="#10-线程的-run-和-start-有什么区别？" class="headerlink" title="10.线程的 run()和 start()有什么区别？"></a>10.线程的 run()和 start()有什么区别？</h2><ul>
<li><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
</li>
<li><p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
</li>
</ul>
<h2 id="11-创建线程池有哪几种方式？"><a href="#11-创建线程池有哪几种方式？" class="headerlink" title="11.创建线程池有哪几种方式？"></a>11.创建线程池有哪几种方式？</h2><h3 id="1-newFixedThreadPool-int-nThreads"><a href="#1-newFixedThreadPool-int-nThreads" class="headerlink" title="1.newFixedThreadPool(int nThreads)"></a>1.newFixedThreadPool(int nThreads)</h3><p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<h3 id="2-newCachedThreadPool"><a href="#2-newCachedThreadPool" class="headerlink" title="2.newCachedThreadPool()"></a>2.newCachedThreadPool()</h3><p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<h3 id="3-newSingleThreadExecutor"><a href="#3-newSingleThreadExecutor" class="headerlink" title="3.newSingleThreadExecutor()"></a>3.newSingleThreadExecutor()</h3><p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<h3 id="4-newScheduledThreadPool-int-corePoolSize"><a href="#4-newScheduledThreadPool-int-corePoolSize" class="headerlink" title="4.newScheduledThreadPool(int corePoolSize)"></a>4.newScheduledThreadPool(int corePoolSize)</h3><p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h2 id="12-线程池都有哪些状态？"><a href="#12-线程池都有哪些状态？" class="headerlink" title="12.线程池都有哪些状态？"></a>12.线程池都有哪些状态？</h2><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>线程池各个状态切换框架图：</p>
<p><img src="/img/posts/java/Thread_Pool.png" srcset="/img/loading.gif" title="线程池状态切换图"></p>
<h3 id="1-RUNNING"><a href="#1-RUNNING" class="headerlink" title="1.RUNNING"></a>1.RUNNING</h3><ul>
<li><p>状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </p>
</li>
<li><p>状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。</p>
</li>
</ul>
<h3 id="2-SHUTDOWN"><a href="#2-SHUTDOWN" class="headerlink" title="2.SHUTDOWN"></a>2.SHUTDOWN</h3><ul>
<li><p>状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </p>
</li>
<li><p>状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
</li>
</ul>
<h3 id="3-STOP"><a href="#3-STOP" class="headerlink" title="3.STOP"></a>3.STOP</h3><ul>
<li><p>状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </p>
</li>
<li><p>状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
</li>
</ul>
<h3 id="4-TIDYING"><a href="#4-TIDYING" class="headerlink" title="4.TIDYING"></a>4.TIDYING</h3><ul>
<li><p>状态说明：当所有的任务已终止，线程池中记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </p>
</li>
<li><p>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
</li>
</ul>
<h3 id="5-TERMINATED"><a href="#5-TERMINATED" class="headerlink" title="5.TERMINATED"></a>5.TERMINATED</h3><ul>
<li><p>状态说明：线程池彻底终止，就变成TERMINATED状态。 </p>
</li>
<li><p>状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
</li>
</ul>
<h2 id="13-线程池中-submit-和-execute-方法有什么区别？"><a href="#13-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="13.线程池中 submit()和 execute()方法有什么区别？"></a>13.线程池中 submit()和 execute()方法有什么区别？</h2><ul>
<li><p>接收的参数不一样。</p>
</li>
<li><p>submit有返回值，而execute没有。</p>
</li>
<li><p>submit方便Exception处理。</p>
</li>
</ul>
<h2 id="14-在java程序中怎么保证多线程的运行安全？"><a href="#14-在java程序中怎么保证多线程的运行安全？" class="headerlink" title="14.在java程序中怎么保证多线程的运行安全？"></a>14.在java程序中怎么保证多线程的运行安全？</h2><p>线程安全在三个方面体现：</p>
<ul>
<li><p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）。</p>
</li>
<li><p>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）。</p>
</li>
<li><p>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>
</li>
</ul>
<h2 id="15-多线程锁的升级原理是什么？"><a href="#15-多线程锁的升级原理是什么？" class="headerlink" title="15.多线程锁的升级原理是什么？"></a>15.多线程锁的升级原理是什么？</h2><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<p>锁升级的图示过程： </p>
<p><img src="/img/posts/java/Lock_Upgrade.png" srcset="/img/loading.gif" title="锁升级的过程"></p>
<blockquote>
<p>锁共有4种状态详解: <a target="_blank" rel="noopener" href="http://ifeve.com/java-synchronized/">http://ifeve.com/java-synchronized/</a></p>
</blockquote>
<h2 id="16-什么是死锁？"><a href="#16-什么是死锁？" class="headerlink" title="16.什么是死锁？"></a>16.什么是死锁？</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p>
<p>死锁的代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建两个对象</span><br>        Object o1 = <span class="hljs-keyword">new</span> Object();<br>        Object o2 = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-comment">// 两个线程公用两个对象</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread1(o1,o2);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread2(o1,o2);<br>        <span class="hljs-comment">// 开启两个线程</span><br>        <span class="hljs-comment">// 以下线程在锁住o1（o2）对象后等待一秒过去正打算锁住o2（o1）对象，但是发现o2（o1）对象已经被锁住。</span><br>        <span class="hljs-comment">// 这时两个线程将会进入到对象锁的锁池中等待，直至其中一个线程解锁对象（这是不可能滴...）。</span><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    Object o1;<br>    Object o2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread1</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.o1 = o1;<br>        <span class="hljs-keyword">this</span>.o2 = o2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (o2)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    Object o1;<br>    Object o2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread2</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.o1 = o1;<br>        <span class="hljs-keyword">this</span>.o2 = o2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (o1)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-怎么防止死锁？"><a href="#17-怎么防止死锁？" class="headerlink" title="17.怎么防止死锁？"></a>17.怎么防止死锁？</h2><p>死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：线程对所分配到的资源不允许其他线程进行访问，若其他线程访问该资源，只能等待，直至占有该资源的线程使用完成后释放该资源。</p>
</li>
<li><p>请求和保持条件：线程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他线程占有，此事请求阻塞，但又对自己获得的资源保持不放。</p>
</li>
<li><p>不可剥夺条件：是指线程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放。</p>
</li>
<li><p>环路等待条件：是指线程发生死锁后，若干线程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。<br>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。<br>所以，在系统设计、线程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免线程永久占据系统资源。<br>此外，也要防止线程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<h2 id="18-ThreadLocal-是什么？有哪些使用场景？"><a href="#18-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="18.ThreadLocal 是什么？有哪些使用场景？"></a>18.ThreadLocal 是什么？有哪些使用场景？</h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。<br>Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。<br>但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。<br>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h2 id="19-synchronized-底层实现原理？"><a href="#19-synchronized-底层实现原理？" class="headerlink" title="19.synchronized 底层实现原理？"></a>19.synchronized 底层实现原理？</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li><p>普通同步方法，锁是当前实例对象</p>
</li>
<li><p>静态同步方法，锁是当前类的class对象</p>
</li>
<li><p>同步方法块，锁是括号里面的对象</p>
</li>
</ul>
<h2 id="20-synchronized-和-volatile-的区别是什么？"><a href="#20-synchronized-和-volatile-的区别是什么？" class="headerlink" title="20.synchronized 和 volatile 的区别是什么？"></a>20.synchronized 和 volatile 的区别是什么？</h2><ul>
<li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
</li>
<li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p>
</li>
<li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p>
</li>
<li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
</li>
<li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
</li>
</ul>
<h2 id="21-synchronized-和-Lock-有什么区别？"><a href="#21-synchronized-和-Lock-有什么区别？" class="headerlink" title="21.synchronized 和 Lock 有什么区别？"></a>21.synchronized 和 Lock 有什么区别？</h2><ul>
<li><p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p>
</li>
<li><p>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p>
</li>
<li><p>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p>
</li>
<li><p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p>
</li>
<li><p>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</p>
</li>
<li><p>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>
</li>
</ul>
<h2 id="22-synchronized-和-ReentrantLock-区别是什么？"><a href="#22-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="22.synchronized 和 ReentrantLock 区别是什么？"></a>22.synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。<br>既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量。</p>
<p>ReentrantLock比synchronized的扩展性体现在几点上： </p>
<ul>
<li><p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </p>
</li>
<li><p>ReentrantLock可以获取各种锁的信息</p>
</li>
<li><p>ReentrantLock可以灵活地实现多路通知 </p>
</li>
</ul>
<p>并且二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p>
<h2 id="23-atomic的原理？"><a href="#23-atomic的原理？" class="headerlink" title="23.atomic的原理？"></a>23.atomic的原理？</h2><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/981222101.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java反射</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/981222104.html">
                        <span class="hidden-mobile">Java容器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
